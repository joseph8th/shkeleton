#!/usr/bin/env bash

####  DECLARATIONS  #######################################################

declare -A SELF_OPTS_HELP   # key: 'self' cmd short opt char
declare -A SELF_OPTARGS     # key: ""

declare -A CMD_HELP         # key: CMD name
declare -A CMD_ARGS         # key: ""
declare -A CMD_OPTS         # key: ""
declare -A CMD_SHORTOPTS    # key: ""

declare -A CMD_LONGOPTS     # key: cmd short opt char
declare -A CMD_OPTS_HELP    # key: ""
declare -A CMD_OPTARGS      # key: ""

# user input params parsed into following variables ...

PARAM=               # system argv as array
CMD=                 # the chosen command OR 'self'
OPTS=                # string of short opts chosen

declare -A ARGS      # positional arguments array
declare -A OPTARGS   # associative array of opt args

# plus some definitions including sourcing user-configured stuff
NOERR=0

SCRIPT=`basename $0`
SCRIPT_SH="${SCRIPT}.sh"    # put your code in ${SCRIPT}.sh
source "${SCRIPT_SH}"


####  UTILITY FUNCTIONS  ##################################################

# error handling
function _err {
    ((NOERR++))
}
function _exit_err {
    printf "\nERROR"
    [ $NOERR -ne 0 ] && printf " (${NOERR})"
    [[ ! -z "$@" ]] && echo ": ${1}" || echo
    echo "Try '${SCRIPT} --help' for more information."
    exit $NOERR
}


# utility function - log debugging info
function _debug {
    [ ${DEBUG} -ne 0 ] && printf "${1}"
}


# function to generate man page
function _gen_man {

    [[ ! -d "./man" ]] && mkdir ./man

    today=$(date +"%d %b %Y")
    manf="./man/${SCRIPT}"

    # man page header data
    printf '.\\"' > $manf
    printf " Manpage for ${SCRIPT}.\n" >> $manf
    printf '.\\"' >> $manf
    printf " Contact ${EMAIL} to correct errors or typos.\n" >> $manf

    str="${str}.TH man ${MAN_TYPE} \"${today}\" \"${VERSION}\" \"${SCRIPT} man page\"\n"

    # name and usage (synopsis)
    str="${str}.SH NAME\n${SELF_NAME}\n"
    str="${str}.SH SYNOPSIS\n${SCRIPT}"

    # usage - self options
    self_opts=( ${CMD_SHORTOPTS[self]} )
    for opt in "${self_opts[@]}"; do
        str="${str} [--${CMD_LONGOPTS[$opt]}"
        [[ ! -z "${SELF_OPTARGS[@]}" ]] && \
            str="${str} ${SELF_OPTARGS[$opt]}]" || \
            str="]"
    done

    # usage - self args || command + opts + args
    if [[ ! -z "${SELF_ARGS}" ]]; then
        str="${str} ${SELF_ARGS}"
    elif [[ ! -z "${COMMANDS[@]}" ]]; then
        str="${str} COMMAND"
        [[ ! -z "${CMD_OPTS[@]}" ]] && str="${str} [OPTS]"
        [[ ! -z "${CMD_ARGS[@]}" ]] && str="${str} [ARGS]"
    fi
    str="${str}\n"

    # self description
    if [[ ! -z "${SELF_HELP}" ]]; then
        str="${str}.SH DESCRIPTION\n${SELF_HELP}\n"
    fi

    # self options - with args and help
    if [[ ! -z "${SELF_OPTS}" ]]; then
        str="${str}.SH OPTIONS\n"

        self_opts=( ${CMD_SHORTOPTS[self]} )
        for opt in "${self_opts[@]}"; do
            str="${str}.IP \"-${opt} --${CMD_LONGOPTS[$opt]}"
            [[ ! -z "${SELF_OPTARGS[$opt]}" ]] && \
                str="${str} ${SELF_OPTARGS[$opt]}\"\n" || \
                str="${str}\"\n"
            str="${str}${SELF_OPTS_HELP[$opt]}\n"
        done
    fi

    # commands - with args and help
    if [[ $((${#COMMANDS[@]}-1)) -gt 0 ]]; then
        str="${str}.SH COMMANDS\n"
    fi
    for cmd in "${COMMANDS[@]}"; do
        [[ "${cmd}" == "self" ]] && continue
        str="${str}.IP \"${cmd} ${CMD_ARGS[$cmd]}\"\n"
        str="${str}${CMD_HELP[$cmd]}\n"
    done

    # command options - with args and help
    if [[ ! -z "${CMD_OPTS[@]}" ]]; then

        # do the same as for SELF_OPTS for each of COMMANDS
        for cmd in "${COMMANDS[@]}"; do
            [[ -z "${CMD_OPTS[$cmd]}" ]] || \
                [[ "${cmd}" == "self" ]] && continue
            str="${str}.SH ${cmd}:\n"

            cmd_opts=( ${CMD_OPTS[$cmd]} )
            cmd_optix=0

            while [[ $cmd_optix -lt ${#cmd_opts[@]} ]]; do
                cmd_opt="${cmd_opts[$cmd_optix]}"
                ((cmd_optix++))
                str="${str}.IP \"-${cmd_opt} --${cmd_opts[$cmd_optix]}"
                [[ ! -z "{CMD_OPTARGS[$cmd_opt]}" ]] && \
                    str="${str} ${CMD_OPTARGS[$cmd_opt]}"
                str="${str}\"\n${CMD_OPTS_HELP[$cmd_opt]}\n"
                ((cmd_optix++))
            done
        done
    fi

    # additonal manpage sections - define more in ${SCRIPT}.sh and add here
    [[ ! -z "${FILES}" ]] && \
        str="${str}.SH FILES\n${FILES}\n"
    [[ ! -z "${ENVIRONMENT}" ]] && \
        str="${str}.SH ENVIRONMENT\n${ENVIRONMENT}\n"
    [[ ! -z "${EXIT_STATUS}" ]] && \
        str="${str}.SH \"EXIT STATUS\"\n${EXIT_STATUS}\n"
    [[ ! -z "${EXAMPLES}" ]] && \
        str="${str}.SH EXAMPLES\n${EXAMPLES}\n"
    [[ ! -z "${BUGS}" ]] && \
        str="${str}.SH BUGS\n${BUGS}\n"
    [[ ! -z "${AUTHOR}" ]] && \
        str="${str}.SH AUTHOR\n${AUTHOR}" && \
        [[ ! -z "${AUTHOR_EMAIL}" ]] && \
        str="${str} <${AUTHOR_EMAIL}>\n" || str="${str}\n"

    # make the manpage
    printf "${str}" >> "./man/${SCRIPT}"
}


# function to print help and return
function _print_help {
    if [[ ${MAN_TYPE} -eq 0 ]]; then
        man "./man/${SCRIPT}"
    else
        echo && man "./man/${SCRIPT}" > "./man/${SCRIPT}.txt" && \
            more "./man/${SCRIPT}.txt"
    fi
}


####  INITIALIZATION  #####################################################

function _init {

    # initialize PARAM from command line
    PARAM=( "$@" )

    # initialize SELF as CMD
    if [[ -z "${COMMANDS}" ]]; then
        COMMANDS=( "self" )
    else
        COMMANDS=( "self" "${COMMANDS[@]}" )
    fi

    CMD_HELP[self]="${SELF_HELP}"
    CMD_ARGS[self]="${SELF_ARGS}"
    CMD_OPTS[self]="${SELF_OPTS}"

    # initialize CMD arrays and associative arrays
    for cmd in "${COMMANDS[@]}"; do
        [[ -z "${CMD_OPTS[$cmd]}" ]] && continue

        # init options
        local opts=( ${CMD_OPTS[$cmd]} )
        local optix=0

        while [[ $optix -lt ${#opts[@]} ]]; do
            opt="${opts[$optix]}"
            CMD_SHORTOPTS[$cmd]="${CMD_SHORTOPTS[$cmd]} ${opt}"
            ((optix++))
            CMD_LONGOPTS[$opt]="${opts[$optix]}"
            ((optix++))
        done
    done

    if [[ ${#SELF_OPTARGS[@]} -ne 0 ]]; then
        self_opts=( ${CMD_SHORTOPTS[self]} )
        for opt in "${self_opts[@]}"; do
            if [[ ! -z "${SELF_OPTARGS[$opt]}" ]]; then
                CMD_OPTARGS[$opt]="${SELF_OPTARGS[$opt]}"
            fi
        done
    fi


    # generate manpage if DEBUG=1 or no manpage exists
    [[ ! -z ${DEBUG} || ! -f "./man/${SCRIPT}" ]] && _gen_man
}


####  COMMAND-LINE PARSING  ###############################################

# utility function - parse to ARGS or OPTARGS
function _set_arg {

    local arg_key=$1        # for either CMD_ARGS[cmd] or CMD_OPTARGS[opt]
    local is_optargs=$2     # flag 1 if seting OPTARGS
    local arg=              # working variable

    # no quote then regular single word argument
    if [[ "${PARAM[0]:0:1}" != '"' ]]; then
        arg="${PARAM[0]}"
        PARAM=( ${PARAM[@]:1} )

    # quoted arguments (\"words lyrics\")
    else
        # get 1st word in quoted arg sans the initial quote
        arg="${PARAM[0]:1}"
        PARAM=( ${PARAM[@]:1} )

        # get words in the middle (no end quote)
        while [[ ${#PARAM[@]} -ne 0 ]] && \
            [[ "${PARAM[0]:(-1)}" != '"' ]]
        do
            arg="${arg} ${PARAM[0]}"
            PARAM=( ${PARAM[@]:1} )
        done

        # if end quote forgotten then err out
        if [[ ${#PARAM[@]} -eq 0 ]] && \
            [[ "${PARAM[0]:(-1)}" != '"' ]]
        then
            err; _exit_err "Imbalanced quotes in argument."
        fi

        # get last word sans end quote
        arg="${arg} ${PARAM[0]%\"}"
        PARAM=( ${PARAM[@]:1} )
    fi

    # then set desired args array at $arg_key
    if [[ $is_optargs -ne 1 ]]; then
        ARGS[$arg_key]="${arg}"
    else
        if [[ -z "${#OPTARGS[@]}" ]]; then
            OPTARGS[$arg_key]="${arg}"
        else
            OPTARGS[$arg_key]="${OPTARGS[@]} ${arg}"
        fi
    fi
}


# parse command (first argument) as you like ...
function _parse_cmd {
    [[ "${#COMMANDS[@]}" == "0" ]] && return   # parse args and opts

    # use regex matching for 1st param (command) since not complicated
    if [[ "${COMMANDS[@]}" =~ "${PARAM[0]} " || \
        "${COMMANDS[${#COMMANDS[@]}-1]}" == "${PARAM[0]}" ]]
    then
        CMD="${PARAM[0]}"
        PARAM=( ${PARAM[@]:1} )
    else
        CMD='self'
    fi

    # optional debugging block
    str="PARSE cmd:\n  cmd: ${CMD} "
    [[ ! -z "${#PARAM[@]}" ]] && \
        str="${str}+ [${PARAM[@]} ]\n" || str="${str}\n"
    str="${str}  rem params (${#PARAM[@]}): ${PARAM[@]}\n"
    _debug "${str}"

    # if arguments expected then print err & exit
    if [[ ${#PARAM[@]} -eq 0 && ! -z "${CMD_ARGS[$CMD]}" ]]; then
        _err; _exit_err "Command arguments expected."
    fi

    # if no more params don't bother parsing args and opts
    [[ "${#PARAM[@]}" == "0" ]] && return 1 || return 0
}


# parse '-' prefixed options ...
function _parse_opts {
    [[ ${#CMD_OPTS[@]} -eq 0 ]] && return   # run cmd with args & opts

    local cmd_opts=( ${CMD_SHORTOPTS[$CMD]} )

    # debugging ...
    str="PARSE opts:\n"

    # loop over PARAM and consume valid opts & optargs
    while [[ ${#PARAM[@]} -gt 0 ]] && [[ "${PARAM[0]:0:1}" == "-" ]]
    do
        for opt in "${cmd_opts[@]}"
        do
            if [[ "-${opt}" == "${PARAM[0]}" ]] || \
                [[ "--${CMD_LONGOPTS[$opt]}" == "${PARAM[0]}" ]]
            then
                OPTS=( ${OPTS[@]} ${opt} )
                PARAM=( ${PARAM[@]:1} )
                cmd_optargs=( ${CMD_OPTARGS[$opt]} )

                echo "${cmd_optargs[@]}"

                if [[ ${#cmd_optargs[@]} -ne 0 ]]; then
                    for optarg in "${cmd_optargs[@]}"; do
                        _set_arg $opt 1
                    done

                    if [ ${#PARAM[@]} -lt ${#cmd_optargs[@]} ]; then
                        _err; _exit_err "Too few option arguments."
                    fi
                fi

                # debugging ...
                str="${str}  opt: -${opt} ${OPTARGS[$opt]}\n"
            fi
        done
    done

    # optional debugging ...
    str="${str}  rem params (${#PARAM[@]}): ${PARAM[@]}\n"
    _debug "${str}"

    [[ "${#PARAM[@]}" == "0" ]] && return 1 || return 0
}


# parse positional arguments as you like ...
function _parse_args {
    [[ "${#CMD_ARGS[@]}" == "0" ]] && return   # no args defined at all

    # get pos args for CMD
    cmd_args=( ${CMD_ARGS[$CMD]} )

    # return if no args defined for $CMD
    [[ "${#cmd_args[@]}" == "0" ]] && return

    # debugging ...
    str="PARSE args:\n"

    # find arg keys for given command & build $ARGS assoc array
    for arg in "${cmd_args[@]}"; do
        [[ -z "${PARAM[0]}" ]] && break

        _set_arg $arg 0

        # debugging ...
        str="${str}  ${arg}=${ARGS[${arg}]}\n"
    done

    # if too few rem params for # of args for this command, then error
    if [[ ${#ARGS[@]} -lt ${#cmd_args[@]} ]]; then
        _err;  _exit_err "Too few positional arguments."
    fi

    # optional debugging ...
    str="${str}  cmd args: $CMD ${cmd_args[@]}\n"
    str="${str}  rem params (${#PARAM[@]}): ${PARAM[@]}\n"
    _debug "${str}"

    [[ "${#PARAM[@]}" == "0" ]] && return 1 || return 0
}


# parameters are $CMD, $ARGS and $OPTS
function _run_params {

    if [[ ${#PARAM[@]} -ne 0 ]]; then
        _err; _exit_err "Too many command line arguments."
    fi

    # debugging ...
    str="RUN params:\n  [${CMD}"
    if [[ ! -z "${OPTS[@]}" ]]; then
        for opt in "${OPTS[@]}"; do
            str="${str}, -${opt}"
            [[ ! -z "${OPTARGS[$opt]}" ]] && str="${str} ${OPTARGS[$opt]}"
        done
    fi
    if [[ ! -z  "${ARGS[@]}" ]]; then
        for arg in "${ARGS[@]}"; do
            str="${str}, ${arg}"
        done
    fi
    _debug "${str}]\n"

    # run the command
    _run_${CMD}
}


####  MAIN  ###############################################################

function _main {

    # initialize & parse command line
    _init "${@}"
    _parse_cmd && _parse_opts && _parse_args

    # error check
    [ ${NOERR} -ne 0 ] && _print_help && \
        _exit_err "Unable to parse command line."

    # run the _run_CMD function with parsed params
    _run_params
}

_main "$@"
exit ${NOERR}
